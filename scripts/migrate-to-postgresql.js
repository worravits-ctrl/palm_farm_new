const sqlite3 = require('sqlite3').verbose();
const { Pool } = require('pg');
const fs = require('fs');
const path = require('path');

class DatabaseMigrator {
  constructor() {
    // SQLite connection
    this.sqliteDb = new sqlite3.Database('./database/palmoil.db');
    
    // PostgreSQL connection - ‡πÉ‡∏ä‡πâ environment variables
    this.pgPool = new Pool({
      connectionString: process.env.DATABASE_URL,
      ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
    });
  }

  async migrate() {
    try {
      console.log('üöÄ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏Å‡∏≤‡∏£ migrate ‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•...\n');

      // 1. ‡∏™‡∏£‡πâ‡∏≤‡∏á schema ‡πÉ‡∏ô PostgreSQL
      await this.createPostgreSQLSchema();

      // 2. Migrate ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• users
      await this.migrateUsers();

      // 3. Migrate ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• harvest_data
      await this.migrateHarvestData();

      // 4. Migrate ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• fertilizer_data
      await this.migrateFertilizerData();

      // 5. Migrate ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• palm_tree_data
      await this.migratePalmTreeData();

      // 6. Migrate ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• notes_data
      await this.migrateNotesData();

      console.log('\n‚úÖ ‡∏Å‡∏≤‡∏£ migrate ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢!');

    } catch (error) {
      console.error('‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£ migrate:', error);
      throw error;
    }
  }

  async createPostgreSQLSchema() {
    console.log('üìã ‡∏™‡∏£‡πâ‡∏≤‡∏á schema ‡πÉ‡∏ô PostgreSQL...');
    
    const schemaSQL = fs.readFileSync(path.join(__dirname, 'database/postgresql-schema.sql'), 'utf8');
    await this.pgPool.query(schemaSQL);
    
    console.log('‚úÖ Schema ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢');
  }

  async migrateUsers() {
    console.log('üë• ‡∏Å‡∏≥‡∏•‡∏±‡∏á migrate ‡∏ï‡∏≤‡∏£‡∏≤‡∏á users...');

    return new Promise((resolve, reject) => {
      this.sqliteDb.all('SELECT * FROM users', async (err, rows) => {
        if (err) {
          reject(err);
          return;
        }

        try {
          for (const row of rows) {
            const query = `
              INSERT INTO users (id, username, email, password, role, is_active, created_at, updated_at)
              VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
              ON CONFLICT (email) DO UPDATE SET
                username = EXCLUDED.username,
                password = EXCLUDED.password,
                role = EXCLUDED.role,
                is_active = EXCLUDED.is_active,
                updated_at = EXCLUDED.updated_at
            `;
            
            await this.pgPool.query(query, [
              row.id,
              row.username,
              row.email,
              row.password,
              row.role,
              row.is_active === 1,
              row.created_at,
              row.updated_at
            ]);
          }

          // Update sequence
          if (rows.length > 0) {
            const maxId = Math.max(...rows.map(r => r.id));
            await this.pgPool.query(`SELECT setval('users_id_seq', $1, true)`, [maxId]);
          }

          console.log(`‚úÖ migrate users ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô (${rows.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£)`);
          resolve();
        } catch (error) {
          reject(error);
        }
      });
    });
  }

  async migrateHarvestData() {
    console.log('üåæ ‡∏Å‡∏≥‡∏•‡∏±‡∏á migrate ‡∏ï‡∏≤‡∏£‡∏≤‡∏á harvest_data...');

    return new Promise((resolve, reject) => {
      this.sqliteDb.all('SELECT * FROM harvest_data', async (err, rows) => {
        if (err) {
          reject(err);
          return;
        }

        try {
          for (const row of rows) {
            const query = `
              INSERT INTO harvest_data 
              (id, user_id, date, total_weight, price_per_kg, total_revenue, harvesting_cost, net_profit, fallen_weight, fallen_price_per_kg, created_at)
              VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
            `;
            
            await this.pgPool.query(query, [
              row.id,
              row.user_id,
              row.date,
              row.total_weight,
              row.price_per_kg,
              row.total_revenue,
              row.harvesting_cost,
              row.net_profit,
              row.fallen_weight || 0,
              row.fallen_price_per_kg || 0,
              row.created_at
            ]);
          }

          // Update sequence
          if (rows.length > 0) {
            const maxId = Math.max(...rows.map(r => r.id));
            await this.pgPool.query(`SELECT setval('harvest_data_id_seq', $1, true)`, [maxId]);
          }

          console.log(`‚úÖ migrate harvest_data ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô (${rows.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£)`);
          resolve();
        } catch (error) {
          reject(error);
        }
      });
    });
  }

  async migrateFertilizerData() {
    console.log('üß™ ‡∏Å‡∏≥‡∏•‡∏±‡∏á migrate ‡∏ï‡∏≤‡∏£‡∏≤‡∏á fertilizer_data...');

    return new Promise((resolve, reject) => {
      this.sqliteDb.all('SELECT * FROM fertilizer_data', async (err, rows) => {
        if (err) {
          reject(err);
          return;
        }

        try {
          for (const row of rows) {
            const query = `
              INSERT INTO fertilizer_data 
              (id, user_id, date, fertilizer_type, amount, cost_per_bag, labor_cost, total_cost, supplier, notes, created_at)
              VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
            `;
            
            await this.pgPool.query(query, [
              row.id,
              row.user_id,
              row.date,
              row.item || row.fertilizer_type || '', // Handle column name differences
              row.sacks || row.amount || 0,
              row.price_per_sack || row.cost_per_bag || 0,
              row.labor_cost || 0,
              row.total_cost,
              row.supplier || '',
              row.notes || '',
              row.created_at
            ]);
          }

          // Update sequence
          if (rows.length > 0) {
            const maxId = Math.max(...rows.map(r => r.id));
            await this.pgPool.query(`SELECT setval('fertilizer_data_id_seq', $1, true)`, [maxId]);
          }

          console.log(`‚úÖ migrate fertilizer_data ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô (${rows.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£)`);
          resolve();
        } catch (error) {
          reject(error);
        }
      });
    });
  }

  async migratePalmTreeData() {
    console.log('üå¥ ‡∏Å‡∏≥‡∏•‡∏±‡∏á migrate ‡∏ï‡∏≤‡∏£‡∏≤‡∏á palm_tree_data...');

    return new Promise((resolve, reject) => {
      this.sqliteDb.all('SELECT * FROM palm_tree_data', async (err, rows) => {
        if (err) {
          reject(err);
          return;
        }

        try {
          for (const row of rows) {
            const query = `
              INSERT INTO palm_tree_data 
              (id, user_id, tree_id, harvest_date, bunch_count, notes, created_at)
              VALUES ($1, $2, $3, $4, $5, $6, $7)
            `;
            
            await this.pgPool.query(query, [
              row.id,
              row.user_id,
              row.palm_tree || row.tree_id || '', // Handle column name differences
              row.date || row.harvest_date,
              row.bunches || row.bunch_count || 0,
              row.note || row.notes || '',
              row.created_at
            ]);
          }

          // Update sequence
          if (rows.length > 0) {
            const maxId = Math.max(...rows.map(r => r.id));
            await this.pgPool.query(`SELECT setval('palm_tree_data_id_seq', $1, true)`, [maxId]);
          }

          console.log(`‚úÖ migrate palm_tree_data ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô (${rows.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£)`);
          resolve();
        } catch (error) {
          reject(error);
        }
      });
    });
  }

  async migrateNotesData() {
    console.log('üìù ‡∏Å‡∏≥‡∏•‡∏±‡∏á migrate ‡∏ï‡∏≤‡∏£‡∏≤‡∏á notes_data...');

    return new Promise((resolve, reject) => {
      this.sqliteDb.all('SELECT * FROM notes_data', async (err, rows) => {
        if (err) {
          reject(err);
          return;
        }

        try {
          for (const row of rows) {
            const query = `
              INSERT INTO notes_data 
              (id, user_id, date, title, content, category, priority, created_at)
              VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
            `;
            
            await this.pgPool.query(query, [
              row.id,
              row.user_id,
              row.date,
              row.title,
              row.content,
              row.category || '‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ',
              row.priority || '‡∏õ‡∏≤‡∏ô‡∏Å‡∏•‡∏≤‡∏á',
              row.created_at
            ]);
          }

          // Update sequence
          if (rows.length > 0) {
            const maxId = Math.max(...rows.map(r => r.id));
            await this.pgPool.query(`SELECT setval('notes_data_id_seq', $1, true)`, [maxId]);
          }

          console.log(`‚úÖ migrate notes_data ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô (${rows.length} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£)`);
          resolve();
        } catch (error) {
          reject(error);
        }
      });
    });
  }

  async close() {
    this.sqliteDb.close();
    await this.pgPool.end();
  }

  async testConnection() {
    try {
      console.log('üîå ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ PostgreSQL...');
      
      const result = await this.pgPool.query('SELECT version()');
      console.log('‚úÖ ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ PostgreSQL ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
      console.log('üìã Version:', result.rows[0].version);
      
      // ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏ï‡∏≤‡∏£‡∏≤‡∏á
      const tables = await this.pgPool.query(`
        SELECT table_name 
        FROM information_schema.tables 
        WHERE table_schema = 'public'
      `);
      
      console.log('üìä ‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÉ‡∏ô PostgreSQL:', tables.rows.map(r => r.table_name));
      
      return true;
    } catch (error) {
      console.error('‚ùå ‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ PostgreSQL ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß:', error.message);
      return false;
    }
  }
}

// ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô migration
if (require.main === module) {
  const migrator = new DatabaseMigrator();
  
  migrator.testConnection()
    .then(connected => {
      if (connected) {
        return migrator.migrate();
      } else {
        throw new Error('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ PostgreSQL ‡πÑ‡∏î‡πâ');
      }
    })
    .then(() => {
      console.log('\nüéâ Migration ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!');
      return migrator.close();
    })
    .catch(error => {
      console.error('\nüí• Migration ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß:', error);
      migrator.close();
      process.exit(1);
    });
}

module.exports = DatabaseMigrator;